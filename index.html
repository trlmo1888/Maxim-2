<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2d1b4e">
    <title>MAXIM ACAAN v99 Standalone</title>
    <style>
/* iOS-Style Timer Component for MAXIM - MEJORADO */

.timer-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #000000;
    display: none;
    z-index: 2000;
    animation: fadeIn 0.3s;
    overflow-y: auto;
}

.timer-modal.active {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.timer-header {
    text-align: center;
    margin-bottom: 40px;
}

.timer-header h2 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 5px;
    color: #ffffff;
}

.timer-header p {
    font-size: 14px;
    opacity: 0.6;
    color: #ffffff;
}

.timer-picker-container {
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    margin-bottom: 30px;
    font-size: 28px;
    font-weight: 300;
    width: 100%;
    max-width: 400px;
}

.picker-wheel {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    height: 200px;
    width: 80px;
    overflow: hidden;
}

.picker-selector {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70px;
    height: 44px;
    border-top: 1px solid rgba(255, 255, 255, 0.4);
    border-bottom: 1px solid rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.03);
    pointer-events: none;
    z-index: 2;
}

.picker-list {
    list-style: none;
    padding: 0;
    margin: 0;
    transform: translateY(0);
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.picker-item {
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: 300;
    opacity: 0.25;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s;
    color: #ffffff;
}

.picker-item.selected {
    opacity: 1;
    font-weight: 400;
    font-size: 28px;
    transform: scale(1.2);
}

.picker-label {
    font-size: 20px;
    opacity: 0.6;
    margin-left: 5px;
    color: #ffffff;
}

.timer-quick-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 25px;
}

.timer-quick-btn {
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 20px;
    color: white;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 70px;
}

.timer-quick-btn:active {
    transform: scale(0.95);
    background: rgba(255, 255, 255, 0.25);
}

.timer-buttons {
    display: flex;
    gap: 20px;
    margin-bottom: 40px;
}

.timer-action-btn {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.timer-cancel-btn {
    background: rgba(255, 255, 255, 0.15);
    color: white;
}

.timer-start-btn {
    background: #34c759;
    color: white;
}

.timer-action-btn:active {
    transform: scale(0.95);
}

.timer-options {
    width: 100%;
    max-width: 400px;
    padding: 0 20px;
}

.timer-option {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 15px 20px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    margin-bottom: 10px;
    font-size: 16px;
    color: #ffffff;
}

.timer-option span {
    opacity: 0.6;
}

.timer-option-value {
    display: flex;
    align-items: center;
    gap: 8px;
    opacity: 1 !important;
}

.timer-running {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 40px;
}

.timer-running.active {
    display: flex;
}

.timer-display {
    font-size: 80px;
    font-weight: 200;
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
    letter-spacing: -2px;
    color: #ffffff;
}

.timer-progress-ring {
    width: 280px;
    height: 280px;
    position: relative;
}

.timer-progress-ring svg {
    transform: rotate(-90deg);
}

.timer-progress-ring circle {
    fill: none;
    stroke-width: 4;
}

.timer-progress-bg {
    stroke: rgba(255, 255, 255, 0.1);
}

.timer-progress-bar {
    stroke: #ff9f0a;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s linear;
}

.timer-control-btns {
    display: flex;
    gap: 40px;
}

.timer-pause-btn,
.timer-stop-btn {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.2s;
}

.timer-pause-btn {
    background: rgba(255, 255, 255, 0.15);
    color: white;
}

.timer-stop-btn {
    background: #ff3b30;
    color: white;
}

.timer-pulse {
    animation: pulse 1s infinite;
}

.timer-stopped {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 40px;
}

.timer-continue-btn {
    width: 200px;
    padding: 18px;
    background: linear-gradient(135deg, #34c759 0%, #2fb84d 100%);
    border: none;
    border-radius: 50px;
    color: white;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.timer-continue-btn:active {
    transform: scale(0.97);
}

.timer-setup {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.6;
    }
}

.hidden {
    display: none !important;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}
    </style>
</head>
<body>
<body>
    <div class="app">
        <div id="notification" class="notification"></div>

        <!-- Main Screen -->
        <div id="mainScreen" class="screen active" style="display: flex; flex-direction: column; height: 100vh; padding: 20px;">
            <div class="logo-section" style="flex-shrink: 0; margin-bottom: 20px;">
                <div class="logo-circle">
                    <span class="letter">M</span>
                </div>
                <div class="app-name">MAXIM ACAAN</div>
            </div>

            <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0;">
                <button class="perform-button" onclick="showTimerFirst()" style="margin-bottom: 20px;">
                    <div class="play-icon"></div>
                    <span>Ejecutar</span>
                </button>

                <div class="menu-grid" style="grid-template-columns: 1fr;">
                    <button class="menu-item" onclick="showScreen('settingsScreen')">
                        <div class="menu-icon">⚙️</div>
                        <div class="menu-label">Ajustes</div>
                    </button>
                </div>
            </div>

            <div style="flex-shrink: 0; text-align: center; opacity: 0.7; font-size: 14px; padding-top: 20px;">
                <div id="currentStackDisplay" style="margin-bottom: 8px;">
                    Stack: <span id="stackNameHome">Mnemonica</span>
                </div>
                <div style="opacity: 0.5; font-size: 12px;">
                    Créditos: T.P.
                </div>
            </div>
        </div>

        <!-- Perform Screen - Step 1: Select Suit -->
        <div id="performScreen" class="perform-screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Selecciona Palo</div>
            </div>

            <div class="card-selector-section">
                <div class="section-label">Palo</div>
                <div class="suits-grid">
                    <button class="suit-button" onclick="selectSuitAndNext('hearts')">♥</button>
                    <button class="suit-button" onclick="selectSuitAndNext('diamonds')">♦</button>
                    <button class="suit-button" onclick="selectSuitAndNext('clubs')">♣</button>
                    <button class="suit-button" onclick="selectSuitAndNext('spades')">♠</button>
                </div>
            </div>
        </div>

        <!-- Perform Screen - Step 2: Select Rank -->
        <div id="rankScreen" class="perform-screen">
            <div class="header">
                <button class="back-button" onclick="showPerformScreen()">←</button>
                <div class="header-title">Selecciona Valor</div>
            </div>

            <div class="card-selector-section">
                <div class="section-label">Valor</div>
                <div class="ranks-grid">
                    <button class="rank-button" onclick="selectRankAndCalculate('A')">A</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('2')">2</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('3')">3</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('4')">4</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('5')">5</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('6')">6</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('7')">7</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('8')">8</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('9')">9</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('10')">10</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('J')">J</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('Q')">Q</button>
                    <button class="rank-button" onclick="selectRankAndCalculate('K')">K</button>
                </div>
            </div>
        </div>

        <!-- Key Card Screen - Step 3: After Timer -->
        <div id="keyCardSuitScreen" class="perform-screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Selecciona Palo</div>
            </div>

            <div class="card-selector-section">
                <div class="section-label">Palo</div>
                <div class="suits-grid">
                    <button class="suit-button" onclick="selectKeySuitAndNext('hearts')">♥</button>
                    <button class="suit-button" onclick="selectKeySuitAndNext('diamonds')">♦</button>
                    <button class="suit-button" onclick="selectKeySuitAndNext('clubs')">♣</button>
                    <button class="suit-button" onclick="selectKeySuitAndNext('spades')">♠</button>
                </div>
            </div>
        </div>

        <!-- Key Card Screen - Step 4: Select Key Rank -->
        <div id="keyCardRankScreen" class="perform-screen">
            <div class="header">
                <button class="back-button" onclick="showScreen('keyCardSuitScreen')">←</button>
                <div class="header-title">Selecciona Valor</div>
            </div>

            <div class="card-selector-section">
                <div class="section-label">Valor</div>
                <div class="ranks-grid">
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('A')">A</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('2')">2</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('3')">3</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('4')">4</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('5')">5</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('6')">6</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('7')">7</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('8')">8</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('9')">9</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('10')">10</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('J')">J</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('Q')">Q</button>
                    <button class="rank-button" onclick="selectKeyRankAndCalculate('K')">K</button>
                </div>
            </div>
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="results-screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Revelaciones</div>
            </div>

            <div style="height: calc(100vh - 80px); overflow-y: auto; padding-bottom: 40px;">
                <div class="selected-card-display">
                    <h2 id="selectedCardName"></h2>
                </div>

                <div class="reveal-methods" id="revealMethods"></div>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Ajustes</div>
            </div>

            <div style="padding: 20px; height: calc(100vh - 80px); overflow-y: auto;">
                <div class="settings-group">
                    <h3>Tipo de Stack</h3>
                    <select id="stackType" onchange="changeStack()">
                        <option value="mnemonica">Mnemonica (Tamariz)</option>
                        <option value="aronson">Aronson Stack</option>
                        <option value="eight-kings">Eight Kings</option>
                        <option value="si-stebbins">Si Stebbins</option>
                    </select>
                    
                    <button onclick="showScreen('stackScreen')" style="
                        margin-top: 15px;
                        width: 100%;
                        padding: 15px;
                        background: linear-gradient(135deg, #c83e51 0%, #e84a5f 100%);
                        border: none;
                        border-radius: 12px;
                        color: white;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                    ">Ver Stack Completo</button>
                </div>

                <div class="settings-group">
                    <h3>Modo Detener Timer</h3>
                    <select id="stopMode" onchange="changeStopMode()">
                        <option value="1">Modo 1: Detener directo</option>
                        <option value="2">Modo 2: Parar sonido primero</option>
                    </select>
                    <p style="font-size: 12px; opacity: 0.7; margin-top: 10px;">
                        Modo 1: Al detener va directo a siguiente pantalla<br>
                        Modo 2: Primera vez para sonido, segunda vez continúa
                    </p>
                </div>

                <div class="settings-group">
                    <h3>Static Outs</h3>
                    <button onclick="showScreen('editOutsScreen')" style="
                        width: 100%;
                        padding: 15px;
                        background: linear-gradient(135deg, #c83e51 0%, #e84a5f 100%);
                        border: none;
                        border-radius: 12px;
                        color: white;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                    ">Editar Static Outs</button>
                </div>

                <div class="settings-group">
                    <h3>Dynamic Outs</h3>
                    
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="dynSumaMinutos" onchange="toggleDynamicOut('sumaMinutos')" style="margin-right: 10px;">
                        <span>Suma de Minutos</span>
                    </label>
                    
                    <div id="sumaMinutosConfig" style="margin-left: 25px; margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                        <p style="font-size: 11px; opacity: 0.7; margin-bottom: 10px;">Elige UNA opción:</p>
                        
                        <label style="display: block; font-size: 12px; margin-bottom: 8px;">
                            <strong>Opción A:</strong> Si faltan menos de
                            <input type="number" id="adelantarSi" value="12" min="0" max="59" 
                                onchange="updateDynamicConfig('sumaMinutos', 'adelantarSi', this.value)"
                                style="width: 50px; margin: 0 3px; padding: 4px; border-radius: 4px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                            segs → Adelanta <strong>1 minuto</strong>
                            <span style="font-size: 10px; opacity: 0.6; display: block; margin-top: 3px;">
                                (Poner 0 para desactivar)
                            </span>
                        </label>
                        
                        <label style="display: block; font-size: 12px; margin-top: 8px;">
                            <strong>Opción B:</strong> Adelantar siempre
                            <input type="number" id="adelantarMinutos" value="0" min="0" max="10"
                                onchange="updateDynamicConfig('sumaMinutos', 'adelantarMinutos', this.value)"
                                style="width: 50px; margin: 0 3px; padding: 4px; border-radius: 4px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                            minutos
                            <span style="font-size: 10px; opacity: 0.6; display: block; margin-top: 3px;">
                                (Poner 0 para desactivar)
                            </span>
                        </label>
                    </div>
                    
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="dynLetrasNombre" onchange="toggleDynamicOut('letrasNombre')" style="margin-right: 10px;">
                        <span>Letras del Nombre</span>
                    </label>
                    
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="dynSumaFecha" onchange="toggleDynamicOut('sumaFecha')" style="margin-right: 10px;">
                        <span>Suma de Fecha</span>
                    </label>
                </div>

                <div class="settings-group">
                    <h3>Opciones de Revelación</h3>
                    <div class="setting-item">
                        <span>Revelación por Fecha</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="dateReveal" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Revelación por Deletreo</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="spellingReveal" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Revelación por Cumpleaños</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="birthdayReveal" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="setting-item">
                        <span>Función Temporizador</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="timerFeature" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>Notificaciones</h3>
                    <div class="setting-item">
                        <span>Vibración</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="vibrationOn" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Edit Outs Screen -->
        <div id="editOutsScreen" class="screen">
            <div class="header">
                <button class="back-button" onclick="showScreen('settingsScreen')">←</button>
                <div class="header-title">Editar Static Outs</div>
            </div>

            <div style="height: calc(100vh - 140px); overflow-y: auto; padding: 20px;">
                <div id="outsEditor"></div>
                
                <button onclick="resetStaticOuts()" style="
                    width: 100%;
                    padding: 15px;
                    margin-top: 20px;
                    background: linear-gradient(135deg, #666 0%, #888 100%);
                    border: none;
                    border-radius: 12px;
                    color: white;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                ">Restaurar Valores por Defecto</button>
            </div>
        </div>

        <!-- Stack Screen -->
        <div id="stackScreen" class="screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Stack</div>
            </div>
            
            <div style="padding: 20px; height: calc(100vh - 80px); overflow-y: auto;">
                <h3 id="currentStackName" style="margin-bottom: 15px; color: #ffffff;">Mnemonica (Tamariz)</h3>
                <div id="stackCardsList" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <!-- Las cartas se generarán aquí -->
                </div>
            </div>
        </div>

        <div id="infoScreen" class="screen">
            <div class="header">
                <button class="back-button" onclick="showMainScreen()">←</button>
                <div class="header-title">Información</div>
            </div>
            <div class="settings-group">
                <h3>Acerca de MAXIM</h3>
                <p style="line-height: 1.6; opacity: 0.9;">MAXIM es una aplicación de revelación de cartas diseñada para magos profesionales. Calcula revelaciones perfectas usando stacks memorizados.</p>
            </div>
        </div>
    </div>

    <script>
// iOS-Style Timer for MAXIM - v18
// Timestamp: 2026-02-16 12:00

console.log('========================================');
console.log('MAXIM TIMER.JS LOADING...');
console.log('========================================');

class IOSTimer {
    constructor() {
        console.log('IOSTimer constructor called');
        this.hours = 0;
        this.minutes = 0;
        this.seconds = 15; // Default 15 segundos
        console.log('Timer initialized with seconds:', this.seconds);
        this.totalSeconds = 0;
        this.remainingSeconds = 0;
        this.interval = null;
        this.isRunning = false;
        this.audio = new Audio('alarm.mp3');
        this.audio.loop = true;
    }

    init() {
        this.createTimerModal();
        this.setupEventListeners();
    }

    createTimerModal() {
        const modal = document.createElement('div');
        modal.id = 'timerModal';
        modal.className = 'timer-modal';
        modal.innerHTML = `
            <div id="timerSetup" class="timer-setup">
                <div class="timer-picker-container">
                    <div class="picker-wheel">
                        <div class="picker-selector"></div>
                        <ul class="picker-list" id="hoursPicker">
                            ${this.generatePickerItems(0, 23, 'h')}
                        </ul>
                    </div>

                    <div class="picker-wheel">
                        <div class="picker-selector"></div>
                        <ul class="picker-list" id="minutesPicker">
                            ${this.generatePickerItems(0, 59, 'min')}
                        </ul>
                    </div>

                    <div class="picker-wheel">
                        <div class="picker-selector"></div>
                        <ul class="picker-list" id="secondsPicker">
                            ${this.generatePickerItems(0, 59, 's')}
                        </ul>
                    </div>
                </div>

                <div class="timer-quick-buttons">
                    <button class="timer-quick-btn" onclick="iosTimer.setQuickTime(0, 0, 15)">15s</button>
                    <button class="timer-quick-btn" onclick="iosTimer.setQuickTime(0, 0, 30)">30s</button>
                    <button class="timer-quick-btn" onclick="iosTimer.setQuickTime(0, 1, 0)">1 min</button>
                </div>

                <div class="timer-buttons">
                    <button class="timer-action-btn timer-cancel-btn" onclick="iosTimer.close()">Cancelar</button>
                    <button class="timer-action-btn timer-start-btn" onclick="iosTimer.start()">Iniciar</button>
                </div>
            </div>

            <div id="timerRunning" class="timer-running">
                <div class="timer-progress-ring">
                    <svg width="280" height="280">
                        <circle class="timer-progress-bg" cx="140" cy="140" r="135"></circle>
                        <circle class="timer-progress-bar" cx="140" cy="140" r="135" 
                                stroke-dasharray="848" stroke-dashoffset="0" id="progressCircle"></circle>
                    </svg>
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                        <div class="timer-display" id="timerDisplay">00:15</div>
                    </div>
                </div>

                <div class="timer-control-btns">
                    <button class="timer-pause-btn" id="pauseBtn" onclick="iosTimer.pauseResume()">Pausar</button>
                    <button class="timer-stop-btn" onclick="iosTimer.stop()">Detener</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    generatePickerItems(start, end, label) {
        let items = '';
        // Padding superior (4 items vacíos)
        for (let i = 0; i < 4; i++) {
            items += `<li class="picker-item">&nbsp;</li>`;
        }
        
        // Números reales
        for (let i = start; i <= end; i++) {
            items += `<li class="picker-item" data-value="${i}">${i}</li>`;
        }
        
        // Padding inferior (4 items vacíos)
        for (let i = 0; i < 4; i++) {
            items += `<li class="picker-item">&nbsp;</li>`;
        }
        
        return items;
    }

    setupEventListeners() {
        this.setupPicker('hoursPicker', (value) => {
            this.hours = parseInt(value) || 0;
        });

        this.setupPicker('minutesPicker', (value) => {
            this.minutes = parseInt(value) || 0;
        });

        this.setupPicker('secondsPicker', (value) => {
            this.seconds = parseInt(value) || 0;
        });
    }

    setupPicker(pickerId, onChange) {
        const picker = document.getElementById(pickerId);
        const items = picker.querySelectorAll('.picker-item');
        
        items.forEach((item, index) => {
            item.addEventListener('click', () => {
                const value = item.getAttribute('data-value');
                if (!value) return;
                
                // Actualizar selección visual
                items.forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
                
                // Centrar el item seleccionado
                this.centerItem(picker, index);
                
                // Callback
                onChange(value);
            });
        });
    }

    centerItem(picker, index) {
        const itemHeight = 40;
        // Queremos que el item seleccionado esté en el CENTRO (entre las líneas)
        // El contenedor tiene 200px de alto, así que el centro está a 100px
        // Cada item tiene 40px, el item debe estar centrado en 100px
        // Entonces: (100 - 20) = 80px desde arriba
        // El item en index 0 empieza en 0, queremos que esté en 80px
        // Offset = index * 40 - 80
        const containerCenter = 100; // Centro del contenedor de 200px
        const itemCenter = 20; // Centro de un item de 40px
        const targetPosition = containerCenter - itemCenter; // 80px
        const currentPosition = index * itemHeight;
        const offset = currentPosition - targetPosition;
        
        picker.style.transform = `translateY(${-offset}px)`;
        picker.style.transition = 'transform 0.3s ease';
    }

    scrollToValue(pickerId, value) {
        const picker = document.getElementById(pickerId);
        const items = picker.querySelectorAll('.picker-item');
        
        items.forEach((item, index) => {
            const itemValue = item.getAttribute('data-value');
            if (itemValue == value) {
                item.classList.add('selected');
                this.centerItem(picker, index);
            } else {
                item.classList.remove('selected');
            }
        });
    }

    open() {
        document.getElementById('timerModal').classList.add('active');
        document.getElementById('timerSetup').style.display = 'flex';
        document.getElementById('timerRunning').classList.remove('active');
        document.getElementById('timerStopped').style.display = 'none';
        
        // Scroll a valores por defecto (0h, 0min, 15s)
        setTimeout(() => {
            this.scrollToValue('hoursPicker', this.hours);
            this.scrollToValue('minutesPicker', this.minutes);
            this.scrollToValue('secondsPicker', this.seconds);
        }, 100);
    }

    close() {
        document.getElementById('timerModal').classList.remove('active');
        this.reset();
    }

    setQuickTime(hours, minutes, seconds) {
        this.hours = hours;
        this.minutes = minutes;
        this.seconds = seconds;
        
        this.scrollToValue('hoursPicker', hours);
        this.scrollToValue('minutesPicker', minutes);
        this.scrollToValue('secondsPicker', seconds);
        
        if ('vibrate' in navigator) {
            navigator.vibrate(30);
        }
    }

    start() {
        this.totalSeconds = (this.hours * 3600) + (this.minutes * 60) + this.seconds;
        
        if (this.totalSeconds === 0) {
            alert('Por favor, configura un tiempo mayor a 0');
            return;
        }

        this.remainingSeconds = this.totalSeconds;
        this.isRunning = true;

        // Cambiar a vista de running
        document.getElementById('timerSetup').style.display = 'none';
        document.getElementById('timerRunning').classList.add('active');

        this.updateDisplay();
        this.updateProgress();
        
        this.interval = setInterval(() => {
            if (this.isRunning) {
                this.remainingSeconds--;
                this.updateDisplay();
                this.updateProgress();

                if (this.remainingSeconds <= 0) {
                    this.finish();
                }
            }
        }, 1000);

        if ('vibrate' in navigator) {
            navigator.vibrate(50);
        }
    }

    pauseResume() {
        this.isRunning = !this.isRunning;
        const pauseBtn = document.getElementById('pauseBtn');
        
        if (this.isRunning) {
            pauseBtn.textContent = 'Pausar';
            document.getElementById('timerDisplay').classList.remove('timer-pulse');
        } else {
            pauseBtn.textContent = 'Continuar';
            document.getElementById('timerDisplay').classList.add('timer-pulse');
        }

        if ('vibrate' in navigator) {
            navigator.vibrate(30);
        }
    }

    stop() {
        // Obtener modo de detener del state
        const stopMode = typeof state !== 'undefined' ? (state.stopMode || 1) : 1;
        
        if (stopMode === 1) {
            // Modo 1: Detener directo
            this.audio.pause();
            this.audio.currentTime = 0;
            clearInterval(this.interval);
            this.isRunning = false;
            
            // Cerrar timer
            document.getElementById('timerModal').classList.remove('active');
            
            // Ir DIRECTAMENTE a pantalla de key card
            setTimeout(() => {
                if (typeof showScreen === 'function') {
                    showScreen('keyCardSuitScreen');
                }
            }, 100);
        } else {
            // Modo 2: Primera vez para sonido, segunda continúa
            if (this.audio.paused) {
                // Ya está parado el sonido, ahora sí continuamos
                clearInterval(this.interval);
                this.isRunning = false;
                
                // Cerrar timer
                document.getElementById('timerModal').classList.remove('active');
                
                // Ir a siguiente pantalla
                setTimeout(() => {
                    if (typeof showScreen === 'function') {
                        showScreen('keyCardSuitScreen');
                    }
                }, 100);
            } else {
                // Primera vez: solo parar sonido
                this.audio.pause();
                this.audio.currentTime = 0;
            }
        }
        
        if ('vibrate' in navigator) {
            navigator.vibrate(50);
        }
    }

    continueToGame() {
        // Esta función ya no se usa
        this.close();
        if (typeof showScreen === 'function') {
            showScreen('keyCardSuitScreen');
        }
    }

    finish() {
        clearInterval(this.interval);
        this.isRunning = false;
        
        // Reproducir alarma
        this.audio.play();
        
        // Vibración
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200, 100, 200]);
        }

        // Mostrar estado final
        document.getElementById('timerDisplay').textContent = '00:00';
        document.getElementById('timerDisplay').classList.add('timer-pulse');
        document.getElementById('pauseBtn').style.display = 'none';
    }

    reset() {
        clearInterval(this.interval);
        this.isRunning = false;
        this.remainingSeconds = 0;
        this.audio.pause();
        this.audio.currentTime = 0;
        
        // Restablecer a valores por defecto
        this.hours = 0;
        this.minutes = 0;
        this.seconds = 15;
        
        const pauseBtn = document.getElementById('pauseBtn');
        if (pauseBtn) {
            pauseBtn.style.display = 'block';
            pauseBtn.textContent = 'Pausar';
        }
        
        const display = document.getElementById('timerDisplay');
        if (display) {
            display.classList.remove('timer-pulse');
        }
    }

    updateDisplay() {
        const hours = Math.floor(this.remainingSeconds / 3600);
        const minutes = Math.floor((this.remainingSeconds % 3600) / 60);
        const seconds = this.remainingSeconds % 60;

        let display = '';
        if (hours > 0) {
            display = `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        } else {
            display = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        document.getElementById('timerDisplay').textContent = display;
    }

    updateProgress() {
        const progress = this.remainingSeconds / this.totalSeconds;
        const circumference = 2 * Math.PI * 135;
        const offset = circumference * (1 - progress);
        
        document.getElementById('progressCircle').style.strokeDashoffset = offset;
    }
}

// Inicializar timer
let iosTimer;
document.addEventListener('DOMContentLoaded', () => {
    iosTimer = new IOSTimer();
    iosTimer.init();
    console.log('Timer initialized');
});
// MAXIM - Card Revelation App
// v18 - 2026-02-16 12:00

console.log('========================================');
console.log('MAXIM APP.JS LOADING...');
console.log('========================================');

// App State
const state = {
    selectedSuit: null,
    selectedRank: null,
    targetCard: null, // Carta que el espectador nombró
    keyCard: null, // Carta de abajo que vemos
    currentStack: 'mnemonica',
    stopMode: 1, // 1 = detener directo, 2 = detener sonido primero
    customStaticOuts: {}, // Se cargará con defaults
    dynamicOutsConfig: {
        sumaMinutos: { enabled: true, adelantarSi: 12, adelantarMinutos: 0 },
        letrasNombre: { enabled: true },
        sumaFecha: { enabled: true }
    },
    timer: {
        seconds: 0,
        interval: null,
        isRunning: false
    },
    stats: {
        performances: 0,
        lastCard: null
    }
};

// Card Stacks
const stacks = {
    mnemonica: [
        '4♣', '2♥', '7♦', '3♣', '4♥', '6♦', 'A♠', '5♥', '9♠', '2♠',
        'Q♥', '3♦', 'Q♣', '8♥', '6♠', '5♠', '9♥', 'K♣', '2♦', 'J♥',
        '3♠', '8♠', '6♥', '10♣', '5♦', 'K♦', '2♣', '3♥', '8♦', 'A♥',
        'K♠', '10♦', 'Q♠', 'J♣', '7♠', 'K♥', 'J♦', 'A♦', '4♠', 'Q♦',
        '7♥', '6♣', '10♠', 'A♣', '9♦', 'J♠', '9♣', '5♣', '8♣', '7♣',
        '4♦', '10♥'
    ],
    aronson: [
        'J♣', 'A♥', '9♠', '2♦', '7♣', '3♥', 'K♦', '4♠', 'A♣', '8♥',
        '5♦', 'Q♠', '6♣', '2♥', '10♦', 'J♠', '3♣', '9♥', '4♦', 'K♠',
        '7♥', 'A♦', '6♠', 'Q♣', '8♦', '3♠', '5♥', '10♠', '2♣', 'K♥',
        '9♦', '4♥', 'J♦', '6♥', 'A♠', 'Q♥', '7♦', '10♣', '5♠', '3♦',
        '8♠', '2♠', 'K♣', '9♣', '6♦', 'J♥', '4♣', 'Q♦', '7♠', '10♥',
        '5♣', '8♣'
    ],
    'eight-kings': generateEightKings(),
    'si-stebbins': generateSiStebbins(),
    custom: []
};

function generateEightKings() {
    const pattern = ['8', 'K', '3', '10', '2', '7', '9', '5', 'Q', '4', 'A', '6', 'J'];
    const suits = ['♣', '♥', '♠', '♦'];
    const deck = [];
    for (let i = 0; i < 52; i++) {
        deck.push(pattern[i % 13] + suits[i % 4]);
    }
    return deck;
}

function generateSiStebbins() {
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    const suits = ['♣', '♥', '♠', '♦'];
    const deck = [];
    let rankIndex = 0, suitIndex = 0;
    for (let i = 0; i < 52; i++) {
        deck.push(ranks[rankIndex] + suits[suitIndex]);
        rankIndex = (rankIndex + 3) % 13;
        suitIndex = (suitIndex + 1) % 4;
    }
    return deck;
}

// Navigation Functions
function showScreen(screenId) {
    try {
        console.log('showScreen called with:', screenId);
        
        const allScreens = document.querySelectorAll('.screen, .perform-screen, .results-screen');
        console.log('Found screens:', allScreens.length);
        
        allScreens.forEach(s => s.classList.remove('active'));
        
        const screen = document.getElementById(screenId);
        console.log('Target screen found:', screen ? 'YES' : 'NO');
        
        if (screen) {
            screen.classList.add('active');
            console.log('Added active class to:', screenId);
        } else {
            console.error('Screen not found:', screenId);
            return;
        }
        
        // Cargar contenido especial según pantalla
        if (screenId === 'editOutsScreen') {
            showEditOuts();
        } else if (screenId === 'settingsScreen') {
            console.log('Loading dynamic outs config...');
            loadDynamicOutsConfig();
        }
        
        vibrate(30);
        console.log('showScreen completed successfully');
    } catch (error) {
        console.error('Error in showScreen:', error);
        alert('Error al cambiar de pantalla: ' + error.message);
    }
}

function showMainScreen() {
    showScreen('mainScreen');
    resetSelection();
}

function showTimerFirst() {
    // Ejecutar → Mostrar pantalla de palos (carta objetivo)
    showPerformScreen();
}

function showPerformScreen() {
    showScreen('performScreen');
    resetSelection();
}

function showRankScreen() {
    showScreen('rankScreen');
}

function showResultsScreen() {
    showScreen('resultsScreen');
}

// Card Selection - Step by Step
function selectSuitAndNext(suit) {
    state.selectedSuit = suit;
    vibrate(50);
    
    const buttons = document.querySelectorAll('.suit-button');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.classList.add('selected');
    
    setTimeout(() => {
        showRankScreen();
    }, 200);
}

function selectRankAndCalculate(rank) {
    state.selectedRank = rank;
    vibrate(50);
    
    // Highlight selected rank
    document.querySelectorAll('.rank-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    event.target.classList.add('selected');
    
    // Guardar carta objetivo (la que buscaremos)
    state.targetCard = formatCard(state.selectedRank, state.selectedSuit);
    
    // Abrir temporizador
    setTimeout(() => {
        if (typeof iosTimer !== 'undefined' && iosTimer) {
            iosTimer.open();
        }
    }, 200);
}

function selectSuit(suit) {
    state.selectedSuit = suit;
    const buttons = document.querySelectorAll('.suit-button');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.classList.add('selected');
    vibrate(30);
}

function selectRank(rank) {
    state.selectedRank = rank;
    const buttons = document.querySelectorAll('.rank-button');
    buttons.forEach(btn => btn.classList.remove('selected'));
    event.target.classList.add('selected');
    vibrate(30);
}

function resetSelection() {
    state.selectedSuit = null;
    state.selectedRank = null;
    const buttons = document.querySelectorAll('.suit-button, .rank-button');
    buttons.forEach(btn => btn.classList.remove('selected'));
}

// Key Card Selection (después del timer)
function selectKeySuitAndNext(suit) {
    state.selectedSuit = suit;
    vibrate(50);
    
    document.querySelectorAll('.suit-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    event.target.classList.add('selected');
    
    setTimeout(() => {
        showScreen('keyCardRankScreen');
    }, 200);
}

function selectKeyRankAndCalculate(rank) {
    state.selectedRank = rank;
    state.keyCard = formatCard(rank, state.selectedSuit);
    vibrate(50);
    
    document.querySelectorAll('.rank-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    event.target.classList.add('selected');
    
    setTimeout(() => {
        calculateTargetPosition();
    }, 200);
}

function calculateTargetPosition() {
    // Calcular posición de la carta objetivo basada en la key card
    const stack = stacks[state.currentStack];
    const keyPosition = stack.indexOf(state.keyCard) + 1;
    const targetPosition = stack.indexOf(state.targetCard) + 1;
    
    if (keyPosition === 0 || targetPosition === 0) {
        showNotification('Error: Carta no encontrada en el stack');
        return;
    }
    
    // Calcular distancia
    let distance;
    if (targetPosition > keyPosition) {
        distance = targetPosition - keyPosition;
    } else {
        distance = (52 - keyPosition) + targetPosition;
    }
    
    displayTargetResults(distance);
    showResultsScreen();
}

// Función para encontrar frase de deletreo
function findSpellingPhrase(targetDistance) {
    const targetName = getCardName(state.targetCard);
    const stack = stacks[state.currentStack];
    
    // Variantes de nombres de cartas
    const variants = [
        targetName, // "Rey de Diamantes"
        targetName.replace(' de ', ' '), // "Rey Diamantes"
        targetName.split(' de ')[0], // "Rey"
        targetName.split(' de ')[1] // "Diamantes"
    ];
    
    let result = null;
    
    // Probar desde arriba
    for (let removeCount = 0; removeCount <= 52; removeCount++) {
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            const finalPosition = removeCount + letterCount;
            
            if (finalPosition === targetDistance) {
                result = {
                    phrase: variant,
                    fromTop: true,
                    remove: removeCount,
                    letterCount: letterCount,
                    exact: true
                };
                return result;
            }
        }
    }
    
    // Probar desde abajo
    for (let removeCount = 0; removeCount <= 52; removeCount++) {
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            const finalPosition = removeCount + letterCount;
            
            if (finalPosition === (52 - targetDistance + 1)) {
                result = {
                    phrase: variant,
                    fromTop: false,
                    remove: removeCount,
                    letterCount: letterCount,
                    exact: true
                };
                return result;
            }
        }
    }
    
    // Si no encontramos exacto, buscar el más cercano
    let bestMatch = null;
    let minRemove = 999;
    
    for (let removeCount = 0; removeCount <= 30; removeCount++) {
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            const finalPositionTop = removeCount + letterCount;
            const finalPositionBottom = removeCount + letterCount;
            
            // Desde arriba
            if (finalPositionTop > targetDistance && removeCount < minRemove) {
                bestMatch = {
                    phrase: variant,
                    fromTop: true,
                    remove: removeCount,
                    letterCount: letterCount,
                    exact: false,
                    needsAdjust: finalPositionTop - targetDistance
                };
                minRemove = removeCount;
            }
            
            // Desde abajo
            if (finalPositionBottom > (52 - targetDistance + 1) && removeCount < minRemove) {
                bestMatch = {
                    phrase: variant,
                    fromTop: false,
                    remove: removeCount,
                    letterCount: letterCount,
                    exact: false,
                    needsAdjust: finalPositionBottom - (52 - targetDistance + 1)
                };
                minRemove = removeCount;
            }
        }
    }
    
    return bestMatch || {
        phrase: targetName,
        fromTop: true,
        remove: 0,
        letterCount: targetName.replace(/\s/g, '').length,
        exact: false
    };
}

// Calculate Reveals
function calculateReveals() {
    if (!state.selectedSuit || !state.selectedRank) {
        showNotification('Por favor, selecciona una carta primero');
        return;
    }

    const card = formatCard(state.selectedRank, state.selectedSuit);
    const position = findPosition(card);

    if (position === -1) {
        showNotification('Carta no encontrada en el stack actual');
        return;
    }

    displayResults(card, position);
    showResultsScreen();
    
    state.stats.performances++;
    state.stats.lastCard = card;
    saveState();
    
    vibrate([50, 100, 50]);
}

function formatCard(rank, suit) {
    const suitSymbols = {
        hearts: '♥',
        diamonds: '♦',
        clubs: '♣',
        spades: '♠'
    };
    return rank + suitSymbols[suit];
}

function findPosition(card) {
    const stack = stacks[state.currentStack];
    return stack.indexOf(card) + 1;
}

function displayTargetResults(distance) {
    const targetName = getCardName(state.targetCard);
    const keyName = getCardName(state.keyCard);
    
    // Buscar la mejor OUT (Dynamic o Static)
    const bestOut = findBestOut(distance, state.currentStack);
    
    document.getElementById('selectedCardName').textContent = 'Revelaciones';
    
    const container = document.getElementById('revealMethods');
    
    // Calcular posiciones
    const posFromTop = distance;
    const posFromBottom = 53 - distance;
    
    // Buscar carta que coincida con las letras
    let matchingCard = null;
    const stack = stacks[state.currentStack];
    for (const card of stack) {
        const cardName = getCardName(card);
        const variants = [cardName, cardName.replace(' de ', ' ')];
        
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            if (letterCount === distance || letterCount === posFromBottom) {
                matchingCard = variant;
                break;
            }
        }
        if (matchingCard) break;
    }
    
    container.innerHTML = `
        <div class="reveal-card" style="background: rgba(255, 255, 255, 0.15); padding: 25px;">
            <h3 style="margin: 0 0 20px 0; font-size: 20px; color: #fff;">💬 ${bestOut.name}</h3>
            <p style="font-size: 22px; font-weight: 600; margin: 15px 0; line-height: 1.5; color: #fff;">
                ${bestOut.text}
            </p>
            
            ${matchingCard ? `
                <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.2);">
                    <p style="font-size: 18px; color: #fff; margin-bottom: 10px;">
                        <strong>Deletrea: "${matchingCard}"</strong>
                    </p>
                </div>
            ` : ''}
            
            <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.2);">
                <p style="font-size: 18px; color: #fff; line-height: 1.8;">
                    <strong>${posFromTop}</strong> desde arriba<br>
                    <strong>${posFromBottom}</strong> desde abajo
                </p>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 30px; padding: 20px; opacity: 0.8; font-size: 16px; border-top: 1px solid rgba(255,255,255,0.2); color: #fff;">
            <div style="margin-bottom: 10px;">🎯 Carta Buscada: <strong>${targetName}</strong></div>
            <div>🔑 Carta Vista: <strong>${keyName}</strong></div>
        </div>
    `;
}

function displayResults(card, position) {
    const cardName = getCardName(card);
    document.getElementById('selectedCardName').textContent = cardName;

    const reveals = generateReveals(card, position, cardName);
    const container = document.getElementById('revealMethods');
    
    container.innerHTML = reveals.map(reveal => `
        <div class="reveal-card">
            <h3>${reveal.icon} ${reveal.title}</h3>
            <p>${reveal.description}</p>
            <div class="reveal-number">${reveal.number}</div>
            <p class="reveal-instruction">${reveal.instruction}</p>
            ${reveal.hasTimer ? `
                <button class="timer-launch-btn" onclick="launchQuickTimer(${reveal.timerSeconds})">
                    ⏱️ Temporizador ${reveal.timerSeconds}s
                </button>
            ` : ''}
        </div>
    `).join('');
}

function launchQuickTimer(seconds) {
    if (typeof iosTimer !== 'undefined' && iosTimer) {
        iosTimer.hours = 0;
        iosTimer.minutes = 0;
        iosTimer.seconds = seconds;
        iosTimer.open();
        
        setTimeout(() => {
            iosTimer.start();
        }, 500);
    }
    
    vibrate(50);
}

function getCardName(card) {
    const rankNames = {
        'A': 'As', '2': 'Dos', '3': 'Tres', '4': 'Cuatro', '5': 'Cinco',
        '6': 'Seis', '7': 'Siete', '8': 'Ocho', '9': 'Nueve', '10': 'Diez',
        'J': 'Jota', 'Q': 'Reina', 'K': 'Rey'
    };
    const suitNames = {
        '♥': 'Corazones', '♦': 'Diamantes', '♣': 'Tréboles', '♠': 'Picas'
    };
    const rank = card.slice(0, -1);
    const suit = card.slice(-1);
    return `${rankNames[rank]} de ${suitNames[suit]}`;
}

function generateReveals(card, position, cardName) {
    const reveals = [];
    const today = new Date();
    const dayOfMonth = today.getDate();

    if (document.getElementById('dateReveal') && document.getElementById('dateReveal').checked) {
        const months = ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 
                       'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'];
        const dateStr = `${dayOfMonth} de ${months[today.getMonth()]}`;
        
        reveals.push({
            icon: '📅',
            title: 'Revelación por Fecha',
            description: `Hoy es ${dateStr}`,
            number: `Posición ${position}`,
            instruction: position === dayOfMonth 
                ? `¡La carta está en la posición ${position} - Cuenta ${dayOfMonth} cartas!`
                : `Desde arriba: ${position} cartas | Desde abajo: ${53 - position} cartas | Hoy: día ${dayOfMonth}`,
            hasTimer: false
        });
    }

    if (document.getElementById('spellingReveal') && document.getElementById('spellingReveal').checked) {
        const letterCount = cardName.replace(/\s/g, '').length;
        reveals.push({
            icon: '🔤',
            title: 'Revelación por Deletreo',
            description: 'Deletrea el nombre de la carta',
            number: `${letterCount} letras`,
            instruction: `"${cardName}" tiene ${letterCount} letras. ¡Cuenta una carta por letra!`,
            hasTimer: true,
            timerSeconds: letterCount
        });
    }

    reveals.push({
        icon: '📍',
        title: 'Posición Directa',
        description: 'Cuenta desde arriba o abajo',
        number: `#${position}`,
        instruction: `Desde arriba: ${position} | Desde abajo: ${53 - position}`,
        hasTimer: false
    });

    const luckyNumbers = [7, 13, 21];
    for (const lucky of luckyNumbers) {
        if (Math.abs(position - lucky) <= 2) {
            reveals.push({
                icon: '🎲',
                title: 'Número de la Suerte',
                description: `Cerca del número ${lucky}`,
                number: `Posición ${position}`,
                instruction: `"Piensa en un número de la suerte... ¿como el ${lucky}?" ¡La carta está en ${position}!`,
                hasTimer: false
            });
            break;
        }
    }

    return reveals.slice(0, 3);
}

// Settings
function changeStack() {
    const selector = document.getElementById('stackType');
    if (selector) {
        state.currentStack = selector.value;
        saveState();
        updateStackDisplay();
        updateHomeStackDisplay();
        showNotification(`Stack cambiado a ${state.currentStack}`);
    }
}

function changeStopMode() {
    const selector = document.getElementById('stopMode');
    if (selector) {
        state.stopMode = parseInt(selector.value);
        saveState();
        showNotification(`Modo detener: ${state.stopMode}`);
    }
}

// Edit Static Outs
function showEditOuts() {
    const container = document.getElementById('outsEditor');
    if (!container) return;
    
    let html = '';
    
    // Posiciones 1-26 (boca arriba)
    html += '<h3 style="margin-top: 0;">Posiciones 1-26 (Boca Arriba)</h3>';
    for (let i = 1; i <= 26; i++) {
        const currentValue = state.customStaticOuts[i] || defaultStaticOuts[i] || '';
        html += `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">
                    Posición ${i}
                </label>
                <input 
                    type="text" 
                    id="out_${i}" 
                    value="${currentValue.replace(/"/g, '&quot;')}"
                    onchange="updateStaticOut(${i})"
                    style="
                        width: 100%;
                        padding: 10px;
                        border: 2px solid rgba(255,255,255,0.2);
                        border-radius: 8px;
                        background: rgba(255,255,255,0.1);
                        color: white;
                        font-size: 14px;
                    "
                />
            </div>
        `;
    }
    
    // Posiciones especiales (boca abajo)
    html += '<h3 style="margin-top: 30px;">Posiciones Especiales (Boca Abajo)</h3>';
    const specialPositions = [43, 44];
    for (const pos of specialPositions) {
        const currentValue = state.customStaticOuts[pos] || defaultStaticOuts[pos] || '';
        html += `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">
                    Posición ${pos} (${53 - pos} boca abajo)
                </label>
                <input 
                    type="text" 
                    id="out_${pos}" 
                    value="${currentValue.replace(/"/g, '&quot;')}"
                    onchange="updateStaticOut(${pos})"
                    style="
                        width: 100%;
                        padding: 10px;
                        border: 2px solid rgba(255,255,255,0.2);
                        border-radius: 8px;
                        background: rgba(255,255,255,0.1);
                        color: white;
                        font-size: 14px;
                    "
                />
            </div>
        `;
    }
    
    container.innerHTML = html;
}

function updateStaticOut(position) {
    const input = document.getElementById(`out_${position}`);
    if (input) {
        state.customStaticOuts[position] = input.value;
        saveState();
        showNotification(`Posición ${position} actualizada`);
    }
}

function resetStaticOuts() {
    if (confirm('¿Restaurar todas las Static Outs a sus valores por defecto?')) {
        state.customStaticOuts = { ...defaultStaticOuts };
        saveState();
        showEditOuts();
        showNotification('Static Outs restauradas');
    }
}

// Dynamic Outs Configuration
function toggleDynamicOut(outName) {
    const checkbox = document.getElementById(`dyn${outName.charAt(0).toUpperCase() + outName.slice(1)}`);
    if (checkbox && state.dynamicOutsConfig[outName]) {
        state.dynamicOutsConfig[outName].enabled = checkbox.checked;
        saveState();
        showNotification(`${outName}: ${checkbox.checked ? 'activada' : 'desactivada'}`);
    }
}

function updateDynamicConfig(outName, property, value) {
    if (state.dynamicOutsConfig[outName]) {
        state.dynamicOutsConfig[outName][property] = parseInt(value);
        saveState();
        showNotification(`Configuración actualizada`);
    }
}

function loadDynamicOutsConfig() {
    try {
        console.log('loadDynamicOutsConfig called');
        // Cargar checkboxes
        const sumaMinutosCheck = document.getElementById('dynSumaMinutos');
        const letrasNombreCheck = document.getElementById('dynLetrasNombre');
        const sumaFechaCheck = document.getElementById('dynSumaFecha');
        
        if (sumaMinutosCheck) sumaMinutosCheck.checked = state.dynamicOutsConfig.sumaMinutos.enabled;
        if (letrasNombreCheck) letrasNombreCheck.checked = state.dynamicOutsConfig.letrasNombre.enabled;
        if (sumaFechaCheck) sumaFechaCheck.checked = state.dynamicOutsConfig.sumaFecha.enabled;
        
        // Cargar valores
        const adelantarSi = document.getElementById('adelantarSi');
        const adelantarMinutos = document.getElementById('adelantarMinutos');
        
        if (adelantarSi) adelantarSi.value = state.dynamicOutsConfig.sumaMinutos.adelantarSi;
        if (adelantarMinutos) adelantarMinutos.value = state.dynamicOutsConfig.sumaMinutos.adelantarMinutos;
        
        console.log('loadDynamicOutsConfig completed');
    } catch (error) {
        console.error('Error in loadDynamicOutsConfig:', error);
    }
}

function updateHomeStackDisplay() {
    const stackNames = {
        'mnemonica': 'Mnemonica',
        'aronson': 'Aronson',
        'eight-kings': 'Eight Kings',
        'si-stebbins': 'Si Stebbins'
    };
    
    const el = document.getElementById('stackNameHome');
    if (el) {
        el.textContent = stackNames[state.currentStack] || state.currentStack;
    }
}

// Utilities
function showNotification(message) {
    const notif = document.getElementById('notification');
    if (notif) {
        notif.textContent = message;
        notif.classList.add('show');
        setTimeout(() => notif.classList.remove('show'), 3000);
    }
}

function vibrate(pattern) {
    if ('vibrate' in navigator) {
        const vibrationOn = document.getElementById('vibrationOn');
        if (!vibrationOn || vibrationOn.checked) {
            navigator.vibrate(pattern);
        }
    }
}

function saveState() {
    try {
        localStorage.setItem('maximState', JSON.stringify(state));
    } catch (e) {
        console.error('Error saving state:', e);
    }
}

function loadState() {
    try {
        const saved = localStorage.getItem('maximState');
        if (saved) {
            const data = JSON.parse(saved);
            Object.assign(state, data);
            state.timer.interval = null;
            state.timer.isRunning = false;
        }
    } catch (e) {
        console.error('Error loading state:', e);
    }
}

function updateStackDisplay() {
    const stackList = document.getElementById('stackCardsList');
    const stackName = document.getElementById('currentStackName');
    
    if (!stackList) return;
    
    const currentStack = stacks[state.currentStack];
    const stackNames = {
        'mnemonica': 'Mnemonica (Tamariz)',
        'aronson': 'Aronson Stack',
        'eight-kings': 'Eight Kings',
        'si-stebbins': 'Si Stebbins'
    };
    
    if (stackName) {
        stackName.textContent = stackNames[state.currentStack] || 'Stack Desconocido';
    }
    
    if (!currentStack) return;
    
    stackList.innerHTML = currentStack.map((card, index) => `
        <div style="
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px 5px;
            text-align: center;
            font-size: 12px;
        ">
            <div style="font-weight: 600; margin-bottom: 3px;">${index + 1}</div>
            <div style="font-size: 18px;">${card}</div>
        </div>
    `).join('');
}

// ============================================
// SISTEMA DE OUTS
// ============================================

// Dynamic Outs Functions
function checkSumaMinutos(position) {
    if (!state.dynamicOutsConfig.sumaMinutos.enabled) return null;
    
    const now = new Date();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();
    
    let willAdvance = false;
    let advanceText = '';
    
    // PRIORIDAD: Opción A > Opción B
    // Opción A: Si faltan menos de X segundos → adelantar 1 minuto (automático)
    const secondsUntilNext = 60 - seconds;
    if (state.dynamicOutsConfig.sumaMinutos.adelantarSi > 0 && secondsUntilNext < state.dynamicOutsConfig.sumaMinutos.adelantarSi) {
        minutes += 1;
        if (minutes >= 60) minutes -= 60;
        willAdvance = true;
        advanceText = 'En 1 min';
    }
    // Opción B: Adelantar X minutos (manual, siempre que X > 0) - SOLO si A no se activó
    else if (state.dynamicOutsConfig.sumaMinutos.adelantarMinutos > 0) {
        minutes += state.dynamicOutsConfig.sumaMinutos.adelantarMinutos;
        if (minutes >= 60) minutes -= 60;
        willAdvance = true;
        advanceText = `En ${state.dynamicOutsConfig.sumaMinutos.adelantarMinutos} min`;
    }
    
    const digit1 = Math.floor(minutes / 10);
    const digit2 = minutes % 10;
    const suma = digit1 + digit2;
    
    if (position === suma) {
        return {
            name: "Suma de Minutos",
            text: willAdvance ? 
                `${advanceText}, la hora sumará ${suma}` :
                `La hora suma ${suma}`,
            position: suma,
            fromBottom: false
        };
    }
    
    const posFromBottom = 53 - position;
    if (posFromBottom === suma) {
        return {
            name: "Suma de Minutos",
            text: willAdvance ?
                `${advanceText}, la hora sumará ${suma}` :
                `La hora suma ${suma}`,
            position: posFromBottom,
            fromBottom: true
        };
    }
    
    return null;
}

function checkLetrasNombre(position, currentStack) {
    if (!state.dynamicOutsConfig.letrasNombre.enabled) return null;
    
    const stack = stacks[currentStack];
    
    for (const card of stack) {
        const cardName = getCardName(card);
        const variants = [cardName, cardName.replace(' de ', ' ')];
        
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            if (letterCount === position) {
                return {
                    name: "Letras del Nombre",
                    text: `Deletrea "${variant}"`,
                    position: position,
                    fromBottom: false
                };
            }
        }
    }
    
    const posFromBottom = 53 - position;
    for (const card of stack) {
        const cardName = getCardName(card);
        const variants = [cardName, cardName.replace(' de ', ' ')];
        
        for (const variant of variants) {
            const letterCount = variant.replace(/\s/g, '').length;
            if (letterCount === posFromBottom) {
                return {
                    name: "Letras del Nombre",
                    text: `Deletrea "${variant}"`,
                    position: posFromBottom,
                    fromBottom: true
                };
            }
        }
    }
    
    return null;
}

function checkSumaFecha(position) {
    if (!state.dynamicOutsConfig.sumaFecha.enabled) return null;
    
    const now = new Date();
    const day = now.getDate();
    const month = now.getMonth() + 1;
    const year = now.getFullYear();
    
    const allDigits = String(day) + String(month) + String(year);
    const sumaTotal = allDigits.split('').reduce((acc, d) => acc + parseInt(d), 0);
    
    if (position === sumaTotal) {
        return {
            name: "Suma de Fecha",
            text: `La fecha suma ${sumaTotal}`,
            position: position,
            fromBottom: false
        };
    }
    
    const posFromBottom = 53 - position;
    if (posFromBottom === sumaTotal) {
        return {
            name: "Suma de Fecha",
            text: `La fecha suma ${sumaTotal}`,
            position: posFromBottom,
            fromBottom: true
        };
    }
    
    return null;
}

function findBestOut(targetPosition, currentStack) {
    const dynamicOuts = [
        checkSumaMinutos(targetPosition),
        checkLetrasNombre(targetPosition, currentStack),
        checkSumaFecha(targetPosition)
    ].filter(out => out !== null);
    
    if (dynamicOuts.length > 0) {
        return dynamicOuts[0];
    }
    
    const staticText = state.customStaticOuts[targetPosition] || defaultStaticOuts[targetPosition] || `Posición ${targetPosition}`;
    const isFromBottom = targetPosition > 26;
    
    return {
        name: "Static Out",
        text: staticText,
        position: targetPosition,
        fromBottom: isFromBottom,
        isStatic: true
    };
}

// Static Outs por defecto (editables por usuario)
const defaultStaticOuts = {
    1: "Da vuelta la carta de arriba",
    2: "Quema la carta de arriba y abajo. Da vuelta la de arriba",
    3: "Quema DOS cartas de arriba y abajo. Da vuelta la de arriba",
    4: "Deletrea ASES",
    5: "Deletrea MAGIA",
    6: "Deletrea MAGIA!",
    7: "Piensa un número entre 1-10 O di que 7 es tu número de suerte",
    8: "Deletrea MISTERIO",
    9: "Han estado mezclando por 9 segundos",
    10: "Deletrea CARTASUERTE",
    11: "Deletrea ABRACADABRA",
    12: "Deletrea ABRACADABRA!",
    13: "Número de mala suerte 13",
    14: "Número de mala suerte 13!",
    15: "Deletrea COMOLOHAZHECHO",
    16: "Deletrea ESTASERAMICARTA",
    17: "Los cronometraste desde 17 segundos",
    18: "Forzaje 20-30!",
    19: "Forzaje 20-30",
    20: "Deletrea CREOQUEESTAESMICARTA",
    21: "Deletrea CREOQUEESTAESMICARTA!",
    22: "Deletrea INCOMPRENSIBILIDADES!",
    23: "El poder del número 23, conocido como 'el enigma 23'",
    24: "El poder del número 23, conocido como 'el enigma 23'!",
    25: "El temporizador marcó 25 segundos",
    26: "El temporizador marcó 26 segundos",
    43: "Forzaje 10-20",
    44: "Forzaje 10-20!"
};

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    console.log('MAXIM: DOM loaded');
    
    loadState();
    
    // Cargar Static Outs (usar defaults si no hay custom)
    if (!state.customStaticOuts || Object.keys(state.customStaticOuts).length === 0) {
        state.customStaticOuts = { ...defaultStaticOuts };
    }
    
    const stackType = document.getElementById('stackType');
    if (stackType) {
        stackType.value = state.currentStack;
    }
    
    const stopMode = document.getElementById('stopMode');
    if (stopMode) {
        stopMode.value = state.stopMode || 1;
    }
    
    updateStackDisplay();
    updateHomeStackDisplay();
    
    console.log('MAXIM: Initialized');
});

// Service Worker - DESACTIVADO TEMPORALMENTE
// Descomenta cuando esté en producción y funcionando correctamente
/*
if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
        navigator.serviceWorker.register('/sw.js')
            .then(reg => console.log('SW registered'))
            .catch(err => console.log('SW registration failed'));
    });
}
*/

console.log('MAXIM: app.js loaded');
console.log('========================================');
console.log('State initialized:', state);
console.log('showScreen function available:', typeof showScreen);
console.log('========================================');
    </script>
</body>
</html>
